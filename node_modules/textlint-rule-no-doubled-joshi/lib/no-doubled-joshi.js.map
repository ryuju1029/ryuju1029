{"version":3,"file":"no-doubled-joshi.js","names":["createSurfaceKeyMap","tokens","filter","is助詞Token","reduce","keyMap","token","tokenKey","createKeyFromKey","push","matchExceptionRule","pos_detail_1","surface_form","length","defaultOptions","min_interval","strict","allow","separatorCharacters","commaCharacters","report","context","options","helper","RuleHelper","minInterval","undefined","Error","isStrict","Syntax","RuleError","is読点Token","create読点Matcher","Paragraph","node","isChildNode","Link","Image","BlockQuote","Emphasis","isSentenceNode","type","SentenceSyntax","Sentence","txtParentNode","splitSentences","SeparatorParser","sentences","children","checkSentence","sentence","sentenceSource","StringSource","replacer","maskValue","Code","text","toString","tokenize","concatTokens","concatJoishiTokens","countableTokens","is括弧Token","includes","joshiTokenSurfaceKeyMap","Object","keys","forEach","key","joshiName","restoreToSurfaceFromKey","indexOf","prev","current","startPosition","otherPosition","differenceIndex","originalIndex","originalIndexFromIndex","word_position","index","Promise","all","map"],"sources":["../src/no-doubled-joshi.ts"],"sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nimport { splitAST as splitSentences, Syntax as SentenceSyntax, SentenceNode } from \"sentence-splitter\";\nimport { tokenize, KuromojiToken } from \"kuromojin\";\nimport {\n    is助詞Token,\n    create読点Matcher,\n    concatJoishiTokens,\n    createKeyFromKey,\n    restoreToSurfaceFromKey,\n    is括弧Token,\n} from \"./token-utils\";\nimport type { TxtNode, TxtParentNode } from \"@textlint/ast-node-types\";\nimport type { TextlintRuleModule } from \"@textlint/types\";\nimport { StringSource } from \"textlint-util-to-string\";\n\n/**\n * Create token map object\n * {\n *  \"は:助詞.係助詞\": [token, token]\n * }\n * @param tokens\n * @returns {*}\n */\nfunction createSurfaceKeyMap(tokens: KuromojiToken[]): { [index: string]: KuromojiToken[] } {\n    // 助詞のみを対象とする\n    return tokens.filter(is助詞Token).reduce((keyMap, token) => {\n        // \"は:助詞.係助詞\" : [token]\n        const tokenKey = createKeyFromKey(token);\n        if (!keyMap[tokenKey]) {\n            keyMap[tokenKey] = [];\n        }\n        keyMap[tokenKey].push(token);\n        return keyMap;\n    }, {} as { [index: string]: KuromojiToken[] });\n}\n\nfunction matchExceptionRule(tokens: KuromojiToken[]) {\n    const token = tokens[0];\n    // \"の\" の重なりは例外\n    if (token.pos_detail_1 === \"連体化\") {\n        return true;\n    }\n    // \"を\" の重なりは例外\n    if (token.pos_detail_1 === \"格助詞\" && token.surface_form === \"を\") {\n        return true;\n    }\n    // 接続助詞 \"て\" の重なりは例外\n    if (token.pos_detail_1 === \"接続助詞\" && token.surface_form === \"て\") {\n        return true;\n    }\n    // 並立助詞は例外\n    // 登ったり降りたり\n    if (tokens.length === 2 && tokens[0].pos_detail_1 === \"並立助詞\" && tokens[1].pos_detail_1 === \"並立助詞\") {\n        return true;\n    }\n    return false;\n}\n\n/*\n default options\n */\nconst defaultOptions = {\n    min_interval: 1,\n    strict: false,\n    allow: [],\n    separatorCharacters: [\n        \".\", // period\n        \"．\", // (ja) zenkaku-period\n        \"。\", // (ja) 句点\n        \"?\", // question mark\n        \"!\", //  exclamation mark\n        \"？\", // (ja) zenkaku question mark\n        \"！\", // (ja) zenkaku exclamation mark\n    ],\n    commaCharacters: [\n        \"、\",\n        \"，\", // 全角カンマ\n    ],\n};\n\nexport interface Options {\n    /**\n     * 助詞の最低間隔値\n     * 指定した間隔値以下で同じ助詞が出現した場合エラーが出力されます\n     * デフォルトは1なので、同じ助詞が連続した場合にエラーとなります。\n     */\n    min_interval?: number;\n    /**\n     * デフォルトの例外パターンもエラーにするかどうか\n     * デフォルト: false\n     */\n    strict?: boolean;\n    /**\n     * 複数回の出現を許す助詞の配列\n     * 例): [\"も\", \"や\"]\n     */\n    allow?: string[];\n    /**\n     * 文の区切りとなる文字(句点)の配列\n     */\n    separatorCharacters?: string[];\n    /**\n     * 読点となる文字の配列\n     */\n    commaCharacters?: string[];\n}\n\n/*\n 1. Paragraph Node -> text\n 2. text -> sentences\n 3. tokenize sentence\n 4. report error if found word that match the rule.\n */\nconst report: TextlintRuleModule<Options> = function (context, options = {}) {\n    const helper = new RuleHelper(context);\n    // 最低間隔値\n    const minInterval = options.min_interval !== undefined ? options.min_interval : defaultOptions.min_interval;\n    if (minInterval <= 0) {\n        throw new Error(\"options.min_intervalは1以上の数値を指定してください\");\n    }\n    const isStrict = options.strict || defaultOptions.strict;\n    const allow = options.allow || defaultOptions.allow;\n    const separatorCharacters = options.separatorCharacters || defaultOptions.separatorCharacters;\n    const commaCharacters = options.commaCharacters || defaultOptions.commaCharacters;\n    const { Syntax, report, RuleError } = context;\n    const is読点Token = create読点Matcher(commaCharacters);\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                return;\n            }\n            const isSentenceNode = (node: TxtNode): node is SentenceNode => {\n                return node.type === SentenceSyntax.Sentence;\n            };\n            const txtParentNode = splitSentences(node as TxtParentNode, {\n                SeparatorParser: {\n                    separatorCharacters,\n                },\n            });\n            const sentences = txtParentNode.children.filter(isSentenceNode);\n            const checkSentence = async (sentence: SentenceNode) => {\n                // コードの中身は無視するため、無意味な文字列に置き換える\n                // @ts-expect-error: sentence-splitterが古いので\n                const sentenceSource = new StringSource(sentence, {\n                    replacer({ node, maskValue }) {\n                        /*\n                         * `obj.method` のCode Nodeのように、区切り文字として意味をもつノードがある場合に、\n                         * このルールでは単純に無視したいので、同じ文字数で意味のない文字列に置き換える\n                         */\n                        if (node.type === Syntax.Code) {\n                            return maskValue(\"_\");\n                        }\n                        return;\n                    }\n                });\n                const text = sentenceSource.toString();\n                const tokens = await tokenize(text);\n                // 助詞 + 助詞は 一つの助詞として扱う\n                // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/15\n                // 連語(助詞)の対応\n                // http://www.weblio.jp/parts-of-speech/%E9%80%A3%E8%AA%9E(%E5%8A%A9%E8%A9%9E)_1\n                const concatTokens = concatJoishiTokens(tokens);\n                const countableTokens = concatTokens.filter((token) => {\n                    if (isStrict) {\n                        return is助詞Token(token);\n                    }\n                    // デフォルトでは、\"、\"などを間隔値の距離としてカウントする\n                    // \"(\"や\")\"などもトークンとしてカウントする\n                    // xxxx（xxx) xxx でカッコの中と外に距離を一つ増やす目的\n                    // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/31\n                    if (is括弧Token(token)) {\n                        return true;\n                    }\n                    // sentence-splitterでセンテンスに区切った場合、 \"Xは「カッコ書きの中の文」と言った。\" というように、「」の中の文は区切られない\n                    // そのため、トークナイズしたトークンで区切り文字となる文字(。や.）があった場合には、カウントを増やす　\n                    // デフォルトではmin_interval:1 なので、「今日は早朝から出発したが、定刻には間に合わなかった。定刻には間に合わなかったが、無事会場に到着した」のようなものがエラーではなくなる\n                    // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/40\n                    if (separatorCharacters.includes(token.surface_form)) {\n                        return true;\n                    }\n                    // \"、\" があると助詞同士の距離が開くようにすることで、並列的な\"、\"の使い方を許容する目的\n                    // https://github.com/azu/textlint-rule-no-doubled-joshi/issues/2\n                    if (is読点Token(token)) {\n                        return true;\n                    }\n                    return is助詞Token(token);\n                });\n                const joshiTokenSurfaceKeyMap = createSurfaceKeyMap(countableTokens);\n                /*\n                    # Data Structure\n\n                    joshiTokens = [tokenA, tokenB, tokenC, tokenD, tokenE, tokenF]\n                    joshiTokenSurfaceKeyMap = {\n                        \"は:助詞.係助詞\": [tokenA, tokenC, tokenE],\n                        \"で:助詞.係助詞\": [tokenB, tokenD, tokenF]\n                    }\n                    */\n                Object.keys(joshiTokenSurfaceKeyMap).forEach((key) => {\n                    const tokens: KuromojiToken[] = joshiTokenSurfaceKeyMap[key];\n                    const joshiName = restoreToSurfaceFromKey(key);\n                    // check allow\n                    if (allow.indexOf(joshiName) >= 0) {\n                        return;\n                    }\n                    // strict mode ではない時例外を除去する\n                    if (!isStrict) {\n                        if (matchExceptionRule(tokens)) {\n                            return;\n                        }\n                    }\n                    if (tokens.length <= 1) {\n                        return; // no duplicated token\n                    }\n                    // if found differenceIndex less than\n                    // tokes are sorted ascending order\n                    tokens.reduce((prev, current) => {\n                        const startPosition = countableTokens.indexOf(prev);\n                        const otherPosition = countableTokens.indexOf(current);\n                        // 助詞token同士の距離が設定値以下ならエラーを報告する\n                        const differenceIndex = otherPosition - startPosition;\n                        if (differenceIndex <= minInterval) {\n                            // padding positionを計算する\n                            const originalIndex = sentenceSource.originalIndexFromIndex(current.word_position - 1);\n                            report(\n                                // @ts-expect-error: SentenceNodeは独自であるため\n                                sentence,\n                                new RuleError(\n                                    `一文に二回以上利用されている助詞 \"${joshiName}\" がみつかりました。`,\n                                    {\n                                        index: originalIndex,\n                                    }\n                                )\n                            );\n                        }\n                        return current;\n                    });\n                });\n            };\n            return Promise.all(sentences.map(checkSentence));\n        },\n    };\n};\nexport default report;\n"],"mappings":"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"}